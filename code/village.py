from mcpi.minecraft import Minecraft
from mcpi.vec3 import Vec3
from mcpi.block import Block

from abstract_region import AbstractRegion
from region_impl.village_region import VillageRegion
from region_impl.pathfinder_region import PathRegion
from region_impl.house_region import HouseRegion

import util
import time


def main() -> bool:
    if __name__ != '__main__':
        return

    start_time = time.time()

    mc = Minecraft.create()

    util.clear_chat(mc)

    util.debug_text(mc, "Village Generator")
    util.debug_text(
        mc, "Created By: (Wai Yan Lin, Chris Park & Mitchell Gertrude)")
    util.debug_text(mc, " ")

    # Generate Initial Village
    # TODO: Method which finds suitable size for village
    x, y, z = mc.player.getPos()
    position = Vec3(x, y-1, z)
    # path = PathRegion(position, position + Vec3(10, 0, 10))
    # path.generate(mc)

    village_region = VillageRegion()
    village_generated = village_region.generate(mc)

    if not village_generated:
        return False

    # Iterate through each region generated by village and generate further
    # print(len(village_region.getHouseRegions()))
    borders = []    
    

    for decor in village_region.getDecorRegions():
        decor.generate(mc)
        borders.extend(util.get_perim(mc, decor))

    for region in village_region.getHouseRegions():      
        borders.extend(util.get_perim(mc, region))

    border_tuples = [(a.x, a.y, a.z) for a in borders]
    for region in village_region.getHouseRegions():     
        path = PathRegion(region.bound1 - Vec3(3, 0 ,3), village_region.getTownCenter(), border_tuples)
        path.generate(mc)   
        region.generate(mc)

    print(border_tuples)
        


    #Generate path


    util.debug_text(mc, f'Execution time: {time.time() - start_time:.5f}s')

    return True


successful_generation = main()
if not successful_generation:
    print("Village Generation Unsuccessful")
